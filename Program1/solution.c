#include <stdio.h>


void main()
{
#pragma region 상수
	////프로그램이 실행되는 동안 더 이상 값을 변경할
	////수 없는 공간입니다.
	//const int data = 100;

	////상수는 메모리 공간을 생성하는 동시에 초기화해야 하며,
	////한 번 저장된 값은 더 이상 변경할 수 없습니다.
	//
	////ex) data = 999;

	//// 상수의 경우 메모리 공간을 가지고 있지 않은 상수를
	////리터럴 상수라고 하며, 메모리 공간을 가지고 있는 상수를 심볼릭 상수라고 함.

	//const float pi = 3.14f;
	//printf("pi의 값: %f\n", pi);
	//// "%f" : 실수(float)를 표현하는 서식 지정자 
    // 정수형 리터럴 상수는 저장하는 값의 범위가 크지 않으면
	//// int 자료형으로 저장되며, 실수형 리터럴 상수는 double
	//// 자료형으로 저장됨
	//float value = 3.1415926535;
	//
	//printf("value의 값 : %.10lf \n", value);
	//// "%lf" : 실수(double)를 표현하는 서식 지정자
	//// %.10lf :	소수점이하 10자리수까지 표현
	//
	////printf() 함수로 소수를 출력할 때 4byte 크기의 실수형
	////자료형은 소수점 이하 6자리 까지만 표기하며, 8byte 크기의
	////실수형 자료형은 소수점 이하 15자리까지만 표기함.

	
#pragma endregion


#pragma region 비트
	// 데이터를 나타는 최소의 단위, 0 or 1의 조합으로
	// 논리 계산을 수행하는 단위

	char character = 10;
	
	//    <<10진수를 2진수로 변환하는 과정>>
	//    10진수를 1이 될 때 까지 2로 계속 나누어 준 다음
	//    나눈 위치의 나머지 값을 아래에서 위로 순서대로 
	//               정렬해준다.

	//    10------> [0][0][0][0][1][0][1][0] 

	// 메모리는 비트 단위로 데이터 저장할 수 있으며,
	// 1개의 비트에는 0 or 1의 값만 저장할 수 있다.

	//   <<2 진수를 10진수로 변환하는 과정 >>
	//  1 byte 에 2진수로 저장된 값을 2의 제곱으로 나타냄
	
	//  각각의 비트에 1이 있다면 1과 2의 제곱의 위치를 계산한 다음
	//  각각의 비트를 모두 더하여 10진수로 나타냄.

	//[0][0][0][0][1][0][1][0] --> (1*2^3)+(0*2^2)+(1*2^1)+(0*2^0) = 10
#pragma endregion

#pragma region 비트_연산자
	// 비트 단위로 논리 연산을 수행하기 위해 
	// 사용하는 연산자이다.

	// <AND 연산자>
	// 두 개의 피연산자가 모두 1이면 1을 반환하는 연산자.

	char x = 10; // 00001010
	char y = 6;  // 00000110 

	printf("x와 y를 AND 연산한 결과: %d \n", x & y);	//00000010 ---> 2

	// <OR 연산자>
	// 두 개의 피연산자 중에 하나라도 1이 있다면 1을 변환하는 연산자.

	printf("x와 y를 OR 연산한 결과: %d \n", x | y ); //00001110 ---> 14


	// <XOR 연산자>
	// 두 개의 피연산자가 서로 같으면 0을 반환하고, 서로다르면
	// 1을 반환하는 연산자.

	printf("x와 y를	XOR 연산한 결과: %d \n", x ^ y);	 //00001100 ---> 12

	// <NOT 연산자>
	// 한 개의 비트를 반전하는 연산자.
	printf("x 변수를 NOT 연산한 결과 : %d \n", ~x); //11110101   -128+(64+32+16+4+1)= -11

	// 첫 번째 비트는 부호를 나타내며 , 첫번째 비트에 1이 있다면 값은 음수, 
	//0이있다면 양수


#pragma endregion


}


